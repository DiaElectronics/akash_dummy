
// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"strings"
	"time"
	"fmt"

	"demo/internal/app"
	"demo/internal/types"
	"github.com/google/uuid"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type User struct {
				ID uuid.UUID `db:"id"`
				Balance types.NullDecimal `db:"balance"`
				Name sql.NullString `db:"name"`
				Role sql.NullString `db:"role"`
}

var UserProps = map[string]columnProps{
		"balance": {
			sqlName:  "balance",
			typeName: "decimal",
		},
		"id": {
			sqlName:  "id",
			typeName: "uuid",
		},
		"name": {
			sqlName:  "name",
			typeName: "string",
		},
		"role": {
			sqlName:  "role",
			typeName: "string",
		},
}
	func (a *Repo) GetUser(id string, isolatedEntityID string) (*app.User, error) {
			return a.getUser(id, isolatedEntityID)
	}

	func (a *Repo) AddUser(profileID string, isolatedEntityID string, m *app.User) (*app.User, error) {
		id, err := a.addUser(profileID, isolatedEntityID, m)
		if err != nil {
			return nil, err
		}
		return a.getUser(id, isolatedEntityID)
	}

	func (a *Repo) DeleteUser(id string, profileID string, isolatedEntityID string) error {
		t := time.Now()
		res, err := a.db.NamedExec(sqlDeleteUser, argDeleteUser{
			ID: id,
			DeletedAt: &t,
			DeletedBy: profileID,
				IsolatedEntityID: isolatedEntityID,
		})
		if err != nil {
			return err
		}
		if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
		}
		
		return nil
	}

	func (a *Repo) EditUser(id string, isolatedEntityID string, m *app.User) (*app.User, error)  {
			if err := a.editUser(id, isolatedEntityID, m); err != nil {
				return nil, err
			}
		

		return a.getUser(id, isolatedEntityID)
	}

	func (a *Repo) ListUser(isolatedEntityID string, params *app.ListParams) ([]*app.User,  int,[]string, error) { 
		ms := []User{}
		warnings := []string{}

		var orderQuery string
		switch params.SortBy {
						case "name":
							orderQuery = "ORDER BY name"
			case "":
			default:
				warnings = append(warnings, fmt.Sprintf("Sorting by '%s' is not avaliable or '%s' is not a valid sort key", params.SortBy, params.SortBy))
		}

		if orderQuery != "" {
			switch params.OrderBy {
			case "ASC", "":
				orderQuery += " ASC"
			case "DESC":
				orderQuery += " DESC"
			}
		}

		bf := newBuilderFilter(params.FilterGroups, UserProps)

		sqlFilters, namedVars, warningsFromPrepared := bf.preparedSQLFilters()
		warnings = append(warnings, warningsFromPrepared...)

		
			namedVars["isolated_entity_id"] = isolatedEntityID
		

		var offset, limit string
			var count int
		var err error
		
				err = a.db.NamedGet(&count, sqlListUserCount+sqlFilters, namedVars)
				if err != nil {
					return nil, -1, nil, err
				}
			offset = " OFFSET :offset"
			namedVars["offset"] = params.Offset
			if params.Limit != 0 {
				limit = " LIMIT :limit"
				namedVars["limit"] = params.Limit
			}
		
		
		err = a.db.NamedSelect(&ms, sqlListUser+sqlFilters+orderQuery+offset+limit, namedVars)
		if err != nil {
			return nil, -1, nil, err
		}
		
		result := ms

		

		return appUsers(result), count, warnings, nil
	}


func (a *Repo) getUser(id string, isolatedEntityID string) (*app.User, error) { 
	var m User
	if err := a.db.NamedGet(&m, sqlGetUser, argGetUser{
		ID: newNullUUID(id),
			IsolatedEntityID: isolatedEntityID, 
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		} 
		return nil, err
	}
	return appUser(m), nil
}

func (a *Repo) addUser(profileID string, isolatedEntityID string, m *app.User) (string, error) {
		UserID := uuid.New().String()
	if err := a.db.NamedGet(&UserID, sqlAddUser, argAddUser{
			ID: UserID,
							Balance: m.Balance,
							Name: m.Name,
							Role: m.Role,
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return "", app.ErrDuplicateID
		}
		return "", err
	}
	return UserID, nil
}

func (a *Repo) getMyUserID(profileID, isolatedEntityID string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMyUserID, argGetMyUserID{
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindToProfileUser(id, profileID, isolatedEntityID string) error {
	res, err := a.db.NamedExec(sqlBindUserToProfile, argBindUserToProfile{
		ID: id,
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) editUser(id string, isolatedEntityID string, m *app.User) error  {

	res, err := a.db.NamedExec(sqlEditUser, argEditUser{
							ID: id,
							Balance: m.Balance,
							Name: m.Name,
							Role: m.Role,
			IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
	}

	return nil
}

func (m *User) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := UserProps[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
			case "id":
						ok = compareUUID(filter.Operator, m.ID, filter.Value)
			case "balance":
						ok = compareDecimal(filter.Operator,  m.Balance.Decimal, filter.Value)
			case "name":
						ok = compareString(filter.Operator, filter.IgnoreCase, m.Name.String, filter.Value)
			case "role":
						ok = compareString(filter.Operator, filter.IgnoreCase, m.Role.String, filter.Value)
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func appUser(m User) *app.User {
	if m.ID.String() == "00000000-0000-0000-0000-000000000000" {
		return nil
	}
	return &app.User{
			ID: m.ID.String(),
			Balance: m.Balance.Decimal,
			Name: m.Name.String,
			Role: m.Role.String,
	}
}

func appUsers(ms []User) []*app.User {
	ams := []*app.User{}
	for _, m := range ms {
		ams = append(ams, appUser(m))
	}

	return ams
}
