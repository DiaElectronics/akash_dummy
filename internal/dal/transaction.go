
// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"strings"
	"time"
	"fmt"

	"demo/internal/app"
	"demo/internal/types"
	"github.com/google/uuid"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type Transaction struct {
				ID uuid.UUID `db:"id"`
				Amount types.NullDecimal `db:"amount"`
				CreatedAt *time.Time `db:"created_at"`
				Info sql.NullString `db:"info"`
				Type sql.NullString `db:"type"`
			UserID sql.NullString `db:"user_id"`
		User User
}

var TransactionProps = map[string]columnProps{
		"amount": {
			sqlName:  "amount",
			typeName: "decimal",
		},
		"createdAt": {
			sqlName:  "created_at",
			typeName: "date-time",
		},
		"id": {
			sqlName:  "id",
			typeName: "uuid",
		},
		"info": {
			sqlName:  "info",
			typeName: "string",
		},
		"type": {
			sqlName:  "type",
			typeName: "string",
		},
		"user": {
			sqlName:  "user_id",
			typeName: "uuid",
		},
}
	func (a *Repo) GetTransaction(id string, isolatedEntityID string) (*app.Transaction, error) {
			return a.getTransaction(id, isolatedEntityID)
	}

	func (a *Repo) AddTransaction(profileID string, isolatedEntityID string, m *app.Transaction) (*app.Transaction, error) {
		id, err := a.addTransaction(profileID, isolatedEntityID, m)
		if err != nil {
			return nil, err
		}
		return a.getTransaction(id, isolatedEntityID)
	}

	func (a *Repo) DeleteTransaction(id string, profileID string, isolatedEntityID string) error {
		t := time.Now()
		res, err := a.db.NamedExec(sqlDeleteTransaction, argDeleteTransaction{
			ID: id,
			DeletedAt: &t,
			DeletedBy: profileID,
				IsolatedEntityID: isolatedEntityID,
		})
		if err != nil {
			return err
		}
		if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
		}
		
		return nil
	}

	func (a *Repo) EditTransaction(id string, isolatedEntityID string, m *app.Transaction) (*app.Transaction, error)  {
			if err := a.editTransaction(id, isolatedEntityID, m); err != nil {
				return nil, err
			}
		

		return a.getTransaction(id, isolatedEntityID)
	}

	func (a *Repo) ListTransaction(isolatedEntityID string, params *app.ListParams) ([]*app.Transaction,  int,[]string, error) { 
		ms := []Transaction{}
		warnings := []string{}

		var orderQuery string
		switch params.SortBy {
			case "":
			default:
				warnings = append(warnings, fmt.Sprintf("Sorting by '%s' is not avaliable or '%s' is not a valid sort key", params.SortBy, params.SortBy))
		}

		if orderQuery != "" {
			switch params.OrderBy {
			case "ASC", "":
				orderQuery += " ASC"
			case "DESC":
				orderQuery += " DESC"
			}
		}

		bf := newBuilderFilter(params.FilterGroups, TransactionProps)

		sqlFilters, namedVars, warningsFromPrepared := bf.preparedSQLFilters()
		warnings = append(warnings, warningsFromPrepared...)

		
			namedVars["isolated_entity_id"] = isolatedEntityID
		

		var offset, limit string
			var count int
		var err error
		
			nestedFilterGroups := bf.nestedFilterGroups()
			
			externalPagination := false
			if len(nestedFilterGroups) != 0  {
				externalPagination = true
			}
			if !externalPagination {
					err = a.db.NamedGet(&count, sqlListTransactionCount+sqlFilters, namedVars)
					if err != nil {
						return nil, -1, nil, err
					}
				offset = " OFFSET :offset"
				namedVars["offset"] = params.Offset
				if params.Limit != 0 {
					limit = " LIMIT :limit"
					namedVars["limit"] = params.Limit
				}
			}
		
		
		err = a.db.NamedSelect(&ms, sqlListTransaction+sqlFilters+orderQuery+offset+limit, namedVars)
		if err != nil {
			return nil, -1, nil, err
		}
		
		result := []Transaction{}
				for i := range ms {
					if err := ms[i].LazyLoading(isolatedEntityID, a); err != nil {
						return nil, -1, nil, err
					}

					ok := true 
					for j, filterGroup := range nestedFilterGroups {
						for _, filter := range filterGroup.Filters {
							var validFilter error
								ok, validFilter = ms[i].NestedFilter(filterGroup.Key, filter)
							if validFilter != nil {
								warnings = append(warnings, fmt.Sprintf("Filter key: '%s'. Error: %s", filterGroup.Key, validFilter.Error()))
								nestedFilterGroups = append(nestedFilterGroups[:j], nestedFilterGroups[j+1:]...)
								j--
							}
							if (!ok && filterGroup.LogicFilter) || (ok && !filterGroup.LogicFilter) {
								break
							}
						}
					}
					if ok {
						result = append(result, ms[i])
					}
				}

		
			if externalPagination {
					count = len(result)
				start, end := pagination(int(params.Offset), int(params.Limit), len(result))
				result = result[start:end]
			}
		

		return appTransactions(result), count, warnings, nil
	}

func (m *Transaction) LazyLoading(isolatedEntityID string, a *Repo) (err error) {
				if err = a.db.NamedGet(&m.User, sqlGetUserForTransactionLazyLoading,  argGetUser{
					ID: m.UserID,
						IsolatedEntityID: isolatedEntityID, 
				}); err != nil && err != sql.ErrNoRows {
					return
				}
	return nil
}

func (a *Repo) getTransaction(id string, isolatedEntityID string) (*app.Transaction, error) { 
	var m Transaction
	if err := a.db.NamedGet(&m, sqlGetTransaction, argGetTransaction{
		ID: newNullUUID(id),
			IsolatedEntityID: isolatedEntityID, 
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		} 
		return nil, err
	}
		if err := m.LazyLoading(isolatedEntityID, a); err != nil {
			return nil, err
		}
	return appTransaction(m), nil
}

func (a *Repo) addTransaction(profileID string, isolatedEntityID string, m *app.Transaction) (string, error) {
		TransactionID := uuid.New().String()
		t := time.Now()
		m.CreatedAt = &t
			var userID interface{}
			if m.User != nil {
				userID = m.User.ID
			}
	if err := a.db.NamedGet(&TransactionID, sqlAddTransaction, argAddTransaction{
			ID: TransactionID,
							Amount: m.Amount,
							CreatedAt: m.CreatedAt,
							Info: m.Info,
							Type: m.Type,
					UserID: userID,
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return "", app.ErrDuplicateID
		}
		return "", err
	}
	return TransactionID, nil
}

func (a *Repo) getMyTransactionID(profileID, isolatedEntityID string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMyTransactionID, argGetMyTransactionID{
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindToProfileTransaction(id, profileID, isolatedEntityID string) error {
	res, err := a.db.NamedExec(sqlBindTransactionToProfile, argBindTransactionToProfile{
		ID: id,
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) editTransaction(id string, isolatedEntityID string, m *app.Transaction) error  {
			var userID interface{}
			if m.User != nil {
				userID = m.User.ID
			}

	res, err := a.db.NamedExec(sqlEditTransaction, argEditTransaction{
							ID: id,
							Amount: m.Amount,
							CreatedAt: m.CreatedAt,
							Info: m.Info,
							Type: m.Type,
					UserID: userID,
			IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
	}

	return nil
}
func (m *Transaction) NestedFilter(key string, filter *app.Filter) (ok bool, err error) {
	if strings.Contains(key, ".") {
		splitedFilter := strings.SplitN(key, ".", 2)
		key = splitedFilter[1]
		switch splitedFilter[0] {
			case "user":
					ok, err = m.User.Filter(key, filter)
		default:
			ok, err = true, errNotExistFilterKey
		}
	} else {
		ok, err = m.Filter(key, filter)
	}
	return
}

func (m *Transaction) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := TransactionProps[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
			case "id":
						ok = compareUUID(filter.Operator, m.ID, filter.Value)
			case "amount":
						ok = compareDecimal(filter.Operator,  m.Amount.Decimal, filter.Value)
			case "createdAt":
						ok = compareTime(filter.Operator, *m.CreatedAt, filter.Value)
			case "info":
						ok = compareString(filter.Operator, filter.IgnoreCase, m.Info.String, filter.Value)
			case "type":
						ok = compareString(filter.Operator, filter.IgnoreCase, m.Type.String, filter.Value)
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func appTransaction(m Transaction) *app.Transaction {
	if m.ID.String() == "00000000-0000-0000-0000-000000000000" {
		return nil
	}
	return &app.Transaction{
			ID: m.ID.String(),
			Amount: m.Amount.Decimal,
			CreatedAt: m.CreatedAt,
			Info: m.Info.String,
			Type: m.Type.String,
			User: appUser(m.User),
	}
}

func appTransactions(ms []Transaction) []*app.Transaction {
	ams := []*app.Transaction{}
	for _, m := range ms {
		ams = append(ams, appTransaction(m))
	}

	return ams
}
