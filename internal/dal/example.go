
// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"strings"
	"time"
	"fmt"

	"demo/internal/app"
	"demo/internal/types"
	"github.com/google/uuid"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type Example struct {
				ID uuid.UUID `db:"id"`
				CpuUnits types.NullDecimal `db:"cpu_units"`
				MemoryMb sql.NullInt32 `db:"memory_mb"`
				Name sql.NullString `db:"name"`
				Price types.NullDecimal `db:"price"`
				StorageMb sql.NullInt32 `db:"storage_mb"`
			UserID sql.NullString `db:"user_id"`
		User User
}

var ExampleProps = map[string]columnProps{
		"cpuUnits": {
			sqlName:  "cpu_units",
			typeName: "decimal",
		},
		"id": {
			sqlName:  "id",
			typeName: "uuid",
		},
		"memoryMb": {
			sqlName:  "memory_mb",
			typeName: "int32",
		},
		"name": {
			sqlName:  "name",
			typeName: "string",
		},
		"price": {
			sqlName:  "price",
			typeName: "decimal",
		},
		"storageMb": {
			sqlName:  "storage_mb",
			typeName: "int32",
		},
		"user": {
			sqlName:  "user_id",
			typeName: "uuid",
		},
}
	func (a *Repo) GetExample(id string, isolatedEntityID string) (*app.Example, error) {
			return a.getExample(id, isolatedEntityID)
	}

	func (a *Repo) AddExample(profileID string, isolatedEntityID string, m *app.Example) (*app.Example, error) {
		id, err := a.addExample(profileID, isolatedEntityID, m)
		if err != nil {
			return nil, err
		}
		return a.getExample(id, isolatedEntityID)
	}

	func (a *Repo) DeleteExample(id string, profileID string, isolatedEntityID string) error {
		t := time.Now()
		res, err := a.db.NamedExec(sqlDeleteExample, argDeleteExample{
			ID: id,
			DeletedAt: &t,
			DeletedBy: profileID,
				IsolatedEntityID: isolatedEntityID,
		})
		if err != nil {
			return err
		}
		if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
		}
		
		return nil
	}

	func (a *Repo) EditExample(id string, isolatedEntityID string, m *app.Example) (*app.Example, error)  {
			if err := a.editExample(id, isolatedEntityID, m); err != nil {
				return nil, err
			}
		

		return a.getExample(id, isolatedEntityID)
	}

	func (a *Repo) ListExample(isolatedEntityID string, params *app.ListParams) ([]*app.Example,  int,[]string, error) { 
		ms := []Example{}
		warnings := []string{}

		var orderQuery string
		switch params.SortBy {
						case "name":
							orderQuery = "ORDER BY name"
			case "":
			default:
				warnings = append(warnings, fmt.Sprintf("Sorting by '%s' is not avaliable or '%s' is not a valid sort key", params.SortBy, params.SortBy))
		}

		if orderQuery != "" {
			switch params.OrderBy {
			case "ASC", "":
				orderQuery += " ASC"
			case "DESC":
				orderQuery += " DESC"
			}
		}

		bf := newBuilderFilter(params.FilterGroups, ExampleProps)

		sqlFilters, namedVars, warningsFromPrepared := bf.preparedSQLFilters()
		warnings = append(warnings, warningsFromPrepared...)

		
			namedVars["isolated_entity_id"] = isolatedEntityID
		

		var offset, limit string
			var count int
		var err error
		
			nestedFilterGroups := bf.nestedFilterGroups()
			
			externalPagination := false
			if len(nestedFilterGroups) != 0  {
				externalPagination = true
			}
			if !externalPagination {
					err = a.db.NamedGet(&count, sqlListExampleCount+sqlFilters, namedVars)
					if err != nil {
						return nil, -1, nil, err
					}
				offset = " OFFSET :offset"
				namedVars["offset"] = params.Offset
				if params.Limit != 0 {
					limit = " LIMIT :limit"
					namedVars["limit"] = params.Limit
				}
			}
		
		
		err = a.db.NamedSelect(&ms, sqlListExample+sqlFilters+orderQuery+offset+limit, namedVars)
		if err != nil {
			return nil, -1, nil, err
		}
		
		result := []Example{}
				for i := range ms {
					if err := ms[i].LazyLoading(isolatedEntityID, a); err != nil {
						return nil, -1, nil, err
					}

					ok := true 
					for j, filterGroup := range nestedFilterGroups {
						for _, filter := range filterGroup.Filters {
							var validFilter error
								ok, validFilter = ms[i].NestedFilter(filterGroup.Key, filter)
							if validFilter != nil {
								warnings = append(warnings, fmt.Sprintf("Filter key: '%s'. Error: %s", filterGroup.Key, validFilter.Error()))
								nestedFilterGroups = append(nestedFilterGroups[:j], nestedFilterGroups[j+1:]...)
								j--
							}
							if (!ok && filterGroup.LogicFilter) || (ok && !filterGroup.LogicFilter) {
								break
							}
						}
					}
					if ok {
						result = append(result, ms[i])
					}
				}

		
			if externalPagination {
					count = len(result)
				start, end := pagination(int(params.Offset), int(params.Limit), len(result))
				result = result[start:end]
			}
		

		return appExamples(result), count, warnings, nil
	}

func (m *Example) LazyLoading(isolatedEntityID string, a *Repo) (err error) {
				if err = a.db.NamedGet(&m.User, sqlGetUserForExampleLazyLoading,  argGetUser{
					ID: m.UserID,
						IsolatedEntityID: isolatedEntityID, 
				}); err != nil && err != sql.ErrNoRows {
					return
				}
	return nil
}

func (a *Repo) getExample(id string, isolatedEntityID string) (*app.Example, error) { 
	var m Example
	if err := a.db.NamedGet(&m, sqlGetExample, argGetExample{
		ID: newNullUUID(id),
			IsolatedEntityID: isolatedEntityID, 
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		} 
		return nil, err
	}
		if err := m.LazyLoading(isolatedEntityID, a); err != nil {
			return nil, err
		}
	return appExample(m), nil
}

func (a *Repo) addExample(profileID string, isolatedEntityID string, m *app.Example) (string, error) {
		ExampleID := uuid.New().String()
			var userID interface{}
			if m.User != nil {
				userID = m.User.ID
			}
	if err := a.db.NamedGet(&ExampleID, sqlAddExample, argAddExample{
			ID: ExampleID,
							CpuUnits: m.CpuUnits,
							MemoryMb: m.MemoryMb,
							Name: m.Name,
							Price: m.Price,
							StorageMb: m.StorageMb,
					UserID: userID,
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return "", app.ErrDuplicateID
		}
		return "", err
	}
	return ExampleID, nil
}

func (a *Repo) getMyExampleID(profileID, isolatedEntityID string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMyExampleID, argGetMyExampleID{
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindToProfileExample(id, profileID, isolatedEntityID string) error {
	res, err := a.db.NamedExec(sqlBindExampleToProfile, argBindExampleToProfile{
		ID: id,
			CreatedBy: profileID,
			IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) editExample(id string, isolatedEntityID string, m *app.Example) error  {
			var userID interface{}
			if m.User != nil {
				userID = m.User.ID
			}

	res, err := a.db.NamedExec(sqlEditExample, argEditExample{
							ID: id,
							CpuUnits: m.CpuUnits,
							MemoryMb: m.MemoryMb,
							Name: m.Name,
							Price: m.Price,
							StorageMb: m.StorageMb,
					UserID: userID,
			IsolatedEntityID: isolatedEntityID,
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
	}

	return nil
}
func (m *Example) NestedFilter(key string, filter *app.Filter) (ok bool, err error) {
	if strings.Contains(key, ".") {
		splitedFilter := strings.SplitN(key, ".", 2)
		key = splitedFilter[1]
		switch splitedFilter[0] {
			case "user":
					ok, err = m.User.Filter(key, filter)
		default:
			ok, err = true, errNotExistFilterKey
		}
	} else {
		ok, err = m.Filter(key, filter)
	}
	return
}

func (m *Example) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := ExampleProps[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
			case "id":
						ok = compareUUID(filter.Operator, m.ID, filter.Value)
			case "cpuUnits":
						ok = compareDecimal(filter.Operator,  m.CpuUnits.Decimal, filter.Value)
			case "memoryMb":
						ok = compareInt64(filter.Operator, int64(m.MemoryMb.Int32), filter.Value)
			case "name":
						ok = compareString(filter.Operator, filter.IgnoreCase, m.Name.String, filter.Value)
			case "price":
						ok = compareDecimal(filter.Operator,  m.Price.Decimal, filter.Value)
			case "storageMb":
						ok = compareInt64(filter.Operator, int64(m.StorageMb.Int32), filter.Value)
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func appExample(m Example) *app.Example {
	if m.ID.String() == "00000000-0000-0000-0000-000000000000" {
		return nil
	}
	return &app.Example{
			ID: m.ID.String(),
			CpuUnits: m.CpuUnits.Decimal,
			MemoryMb: m.MemoryMb.Int32,
			Name: m.Name.String,
			Price: m.Price.Decimal,
			StorageMb: m.StorageMb.Int32,
			User: appUser(m.User),
	}
}

func appExamples(ms []Example) []*app.Example {
	ams := []*app.Example{}
	for _, m := range ms {
		ams = append(ams, appExample(m))
	}

	return ams
}
